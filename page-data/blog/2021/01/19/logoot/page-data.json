{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2021/01/19/logoot","result":{"data":{"allMarkdownRemark":{"nodes":[{"html":"<p>If you prefer the more mathematically rigorous explanation, you can find the original article\n<a href=\"https://hal.inria.fr/inria-00432368/document/\">here</a>. This section will serve as a more practical explanation of Logoot for\nthose who are not yet familiar.</p>\n<p>Logoot distills the problem of collaborative editing to a problem of ordering. Logoot splits the document into single,\nindivisible <em>atoms</em>. These could be characters, Unicode grapheme clusters, images, bullet points, or pretty much\nanything. Consider the string <code>\"hello\"</code>. If this is stored as an array, I could assign numbers 0-4 (inclusive) to each\nletter. This can be modeled as a mapping from a single, numeric index to the data (a letter or nothing) stored at that\nindex. I can modify the value at each index, which allows me to quite easily append characters to each end of the\nstring. However, it is quite difficult to insert a character in the middle of my string: I would have to shift over\nevery index by replacing the values to make space for the new value. However, this is inefficient and will not be able\nto handle concurrent edits in a reasonable way.</p>\n<p>So, there needs to be a way of storing positions <em>between</em> other positions. Mathematically, we know that there are\ninfinite decimals between any two integers. Variable precision decimals are represented using floating points, but using\nthese for positions wouldn't work too well, though: You'd quickly run out of available positions since floating point\nprecision is not infinite. These are the same issues that would be encountered when using standard, fixed-precision\nintegers.</p>\n<h1>Positions as arrays</h1>\n<p>The solution, seems to be to allow an infinitely long integer to specify more points with indefinite precision. Instead\nof defining each of our positions as a single integer, we can define them as an array of integers. The map would look\nsomething like this: (for the string <code>\"abd\"</code>)</p>\n<pre><code>[0] -> 'a'\n[1] -> 'b'\n[2] -> 'd'\n</code></pre>\n<p>To add a <code>'c'</code> between the <code>'b'</code> and <code>'d'</code>, we simply need a position between them. Finding one easy: Let's call it\n<code>[1,1]</code>:</p>\n<pre><code>[0]   -> 'a'\n[1]   -> 'b'\n[1,1] -> 'c'\n[2]   -> 'd'\n</code></pre>\n<p>We can keep doing this by adding more and more elements to the array as necessary. We will <em>always</em> be able to find\na position between any other two. It is worth noting having many atoms can cause memory issues, which will be discussed\nin more depth later.</p>\n<h2>A note about positions</h2>\n<p>Here, I used <code>[1,1]</code> as an example position between <code>[1]</code> and <code>[2]</code>. Especially when there's just two numbers in the\narray, it's easy to mistake these for decimals. However, there's one key difference: Adding another element in the array\n<em>always</em> makes the position greater. In other words, mathematically, <code>1</code> is the same number as <code>1.0</code>, but with these\npositions, that is <strong>not</strong> the case. The position <code>[1,0]</code> is greater than <code>[1]</code>. Furthermore, the same is true even if\nthe second number is negative: <code>[1,-9000] > [1]</code>. Like decimals, the goal of this approach is to make infinite space\nbetween two existing positions, however, they behave quite differently.</p>\n<h2>Removals</h2>\n<p>Removing these atoms is simple. If we wanted to remove the letter <code>b</code> from the example above, all we would need to do is\nrecord that the position <code>[1]</code> has been removed. It would be just as easy to record a new operation to add a new\ncharacter back into the same position. So long as the events are replayed in order, the same order should always result.</p>\n<h1>Fixing the ordering problem</h1>\n<p>For this to work, the edits must be applied in exactly the same order. Iin distributed systems, this can become\ncomplicated. Consider that a user inserts the letter <code>a</code>, then deletes it, then inserts the letter <code>b</code>. If the order is\nrandomized, then the state of that region of text could be quite different: It could end up being <code>a</code>, <code>b</code>, or it could\nend up being removed entirely.</p>\n<p>Rather than ensuring that all of the operations are properly ordered, it's easier to properly handle an unordered\noperation when it is processed. To do this, each atom is assigned a <a href=\"https://en.wikipedia.org/wiki/Lamport_timestamp\">Lamport clock</a>.\nWhenever a new character is inserted over an old one, this clock is incremented. When a removal is recorded, the clock\ntakes the same Lamport clock of the data being removed. When receiving an operation, atoms with a higher Lamport clock\nwill take precedence. If they're equal, then the removal will take precedence. Now, in our previous example, the\nfollowing operations could be recorded: (Where the number after the <code>@</code> is the new Lamport clock)</p>\n<pre><code>INSERT 'a' -> [0] @ 0\nREMOVE [0] @ 0\nINSERT 'b' -> [1] @ 1\n</code></pre>\n<p>If the order is reversed, the insertion of <code>b</code> is received and added to the document. Next, the removal of <code>[0] @ 0</code> is\nreceived. No action is taken since the Lamport clock of <code>0</code> is lower than the existing atom's clock of <code>1</code>. The same would go for the insertion of <code>a</code>.</p>\n<p>If the order is the same, except that the removal is seen first, the receiver would actually have to record a removal at\n<code>[0] @ 0</code> and store it in memory. This is because the receiver would have to know to ignore the <code>a</code> when it is processed\nnext to ensure that the removal has the desired effect. That allows a removal to be received <em>before</em> the content that\nit's supposed to remove. Finally, the <code>b</code> is inserted over the removal (which can now be forgotten) since it has a\nhigher Lamport clock.</p>\n<h2>Side note: Logootish</h2>\n<p>There was a predecessor to AnchorLogoot known simply as Logootish. Logootish stopped here and implemented Logoot as\ndescribed above, but added a detection mechanism for nodes inserted by users on parallel \"branches.\" This was the\nalgorithm that I talked about on <a href=\"https://matrix.org/blog/2020/02/21/this-week-in-matrix-2020-02-21#matrix-live-\">Matrix Live</a>.\nHowever, I'd already come up with AnchorLogoot a while ago. Nearly three months later, I realized that Logootish was too\ncomplicated and that implementing AnchorLogoot was likely less work for an overall better algorithm. So, I started the\n<code>kb1rd-breaking-stuff</code> branch to work on AnchorLogoot instead. The original Logootish code is\n<a href=\"https://github.com/anchor-logoot/logootish-js/tree/68e04b8dfaa3868fb94cb3f674fc0d95b4aa42a5\">here</a>.</p>\n<h1>Simultaneous Edits</h1>\n<p>While this all works well for one user, we're still missing one small thing. Let's say that two users edit textvat the\nsame location, but they're both offline. When they sync up again, one user's edits will overwrite the other's. If only\nthere were some way to divide up positions so that only one user can edit a particular position, the problem would\nseemingly be solved. Of course, there is! Let's assume that there are three users, U1-3. Instead of using integers for\neach element of the position array, we can use a tuple of <code>(pos, user)</code>. To order two of these tuples, first the numeric\nposition is ordered. If these are the same, then the tuples are ordered by the user field. Here's an example of a valid\nordering:</p>\n<pre><code>[(0, U1)], [(0, U2)], [(0, U1),(1, U1)], [(0, U1),(1, U3)], [(1, U1)]\n</code></pre>\n<p>This changes allocations slightly. If a user wants to insert an atom, they must insert it such that the last element of\nthe array has the user component of the tuple set to the current user. This ensures that it's impossible for two users\nto concurrently insert at the same position. As with the old positions, it's always possible to find a position between\ntwo others. The main difference in allocation methods shows up when there are two consecutive atoms from different\nusers. Consider the positions <code>[(0, U1)]</code> and <code>[(0, U2)]</code>. If <code>U3</code> wants to insert between these two atoms, they can use\nthe position <code>[(0,U1), (0,U3)]</code>.</p>\n<p>Hopefully, Logoot makes a bit more sense now. In the next post in this series, I'll explore some of the problems with\nLogoot and potential fixes for them.</p>","frontmatter":{"title":"Explanation of AnchorLogoot Part 1: Logoot in a nutshell","description":"This will be the first post in a series that I'm working on about the CRDT algorithm that I developed known as AnchorLogoot. As a derivative of Logoot, it's easiest to understand Logoot before trying to understand my algorithm. I found the Logoot paper to be a bit on the technical side, so this is explanation will hopefully be a bit more user-friendly.","tags":["technology","CRDT","collaboration","algorithm"],"date":"January 19, 2021","image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACWklEQVQ4y+WUy08TURSH5090b/wHjIkRTYwxxmCURLYguEBUHilgQARBimI7pbaAIKSv2BBZGKKNYGemnUcfQz/PnXYMVhcuWJi4ODl3zj2/75z7Gs11Xc7StH8f6DgOoanAad9toehP8dAHQNu2/xrYDe6OaY1GA9/3qdfrbWGQ0E6q1Wp4nhf4n0VOAdTcrxoBZjIZ1pNJisUidYGrbkOxruvkCwVyuVwwr4qrOdM02draYnNzE6tSwQ3BCqjH4zyfm2UjncYXgWNXqXkuFUmMx2IU8jl2tt+TlcJ+s4knQMMw2BbgRjqFJeOa6tZVXTtoKbPJ63KTeKVF0oOYeSLmc2y7ZG2fWAWSDuji3xg+21aTsu2QkHwVU5p1G1Zlbr9aR3thtBg3YeSgTH8qz8SRT6QMJdsLEgf3j+kZn2fim8/Yd4iK8NjxmJLxpOT16bs8/FhiTBgfLAEuWzAjwr5oinOXr3N3JcWCVP1q2aSks2FJPn/rHhcHHjFc+EJcco8qNouS07uUoGd0hqG9AyLC2VPAqAsRA66MRLjQ28+18TkW621gWuYGMp+59OCxCKfpf5cjIaAjq8rLGtxeiHH1yTOGdj8RMTvABYFNyMegCO8nswzmDpmSWKnqolsnjJYa3JiNcnN+jaey7FWzFezvtCx3UpZ9J5pmKH8YbFuw5IQcynLZ560sJSbV1zobrPZpx2rwSgCJBiSk6xUZb8ihGHI91AGtGifo0qnSLgmjqA7FCW+93L/2i7F/ewV2tRrY6Ysd+u5Xprmd+3NWpoVP5qxM+/9+sD8ATfXWgRo8eQ4AAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/182f4e1a9afdb63cd7207576523bd2cb/bcdb9/2021-01-19%20Logoot.png","srcSet":"/static/182f4e1a9afdb63cd7207576523bd2cb/20ef8/2021-01-19%20Logoot.png 256w,\n/static/182f4e1a9afdb63cd7207576523bd2cb/627d4/2021-01-19%20Logoot.png 512w,\n/static/182f4e1a9afdb63cd7207576523bd2cb/bcdb9/2021-01-19%20Logoot.png 1024w,\n/static/182f4e1a9afdb63cd7207576523bd2cb/32d37/2021-01-19%20Logoot.png 1536w,\n/static/182f4e1a9afdb63cd7207576523bd2cb/59169/2021-01-19%20Logoot.png 2048w","sizes":"(max-width: 1024px) 100vw, 1024px"}}}}}]}},"pageContext":{"id":"73fd991c-6c4c-5cfd-ac1b-15a3b69b7fb8"}},"staticQueryHashes":["3248290905","3485864023"]}